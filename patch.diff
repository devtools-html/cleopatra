diff --git a/src/test/components/Viewport.test.js b/src/test/components/Viewport.test.js
index 0c2a9ef4..8b438eb6 100644
--- a/src/test/components/Viewport.test.js
+++ b/src/test/components/Viewport.test.js
@@ -7,16 +7,19 @@ import * as React from 'react';
 import { Provider } from 'react-redux';
 import { mount } from 'enzyme';
 
 import { withChartViewport } from '../../components/shared/chart/Viewport';
 import {
   getCommittedRange,
   getPreviewSelection,
 } from '../../reducers/profile-view';
+
+import { changeSidebarOpenState } from '../../actions/app';
+
 import explicitConnect from '../../utils/connect';
 import mockCanvasContext from '../fixtures/mocks/canvas-context';
 import mockRaf from '../fixtures/mocks/request-animation-frame';
 import { storeWithProfile } from '../fixtures/stores';
 import { getBoundingBox, getMouseEvent } from '../fixtures/utils';
 import { getProfileFromTextSamples } from '../fixtures/profiles/make-profile';
 
 // The following define the magic values used for the mocked bounding box of the
@@ -464,40 +467,87 @@ describe('Viewport', function() {
       });
 
       // Perform the dragging action some arbitrarily large distance.
       clickAndDrag(middleX, middleY, middleX - 10000, middleY);
       expect(getChartViewport().viewportLeft).toBeGreaterThan(0.6);
       expect(getChartViewport().viewportRight).toBe(1);
     });
   });
+
+  it('reacts to changes to the panel layout generation', function() {
+    const {
+      dispatch,
+      setBoundingBoxMock,
+      getChartViewport,
+      flushRafCalls,
+      view,
+    } = setup();
+
+    const {
+      containerWidth: initialContainerWidth,
+      containerHeight: initialContainerHeight,
+    } = getChartViewport();
+
+    // add something here :-)
+    expect(true).toBe(false);
+
+    setBoundingBoxMock({ width: BOUNDING_BOX_WIDTH - 15 });
+    dispatch(changeSidebarOpenState('calltree', true));
+    flushRafCalls();
+    view.update();
+
+    const { containerWidth, containerHeight } = getChartViewport();
+
+    // add something here :-)
+    expect(true).toBe(false);
+  });
 });
 
+type BoundingBoxOverride = {
+  width: number,
+  height: number,
+  offsetX: number,
+  offsetY: number,
+};
+
+function getBoundingBoxForViewport(override: $Shape<BoundingBoxOverride> = {}) {
+  const values: BoundingBoxOverride = Object.assign(
+    {
+      width: BOUNDING_BOX_WIDTH,
+      height: BOUNDING_BOX_HEIGHT,
+      offsetX: BOUNDING_BOX_LEFT,
+      offsetY: BOUNDING_BOX_TOP,
+    },
+    override
+  );
+
+  const rect = getBoundingBox(values.width, values.height);
+  // Add some arbitrary offset to the bounding box to ensure that we
+  // are doing the correct thing when doing sizing calculations.
+  rect.left += values.offsetX;
+  rect.right += values.offsetX;
+  rect.x += values.offsetX;
+  rect.y += values.offsetY;
+  rect.top += values.offsetY;
+  rect.bottom += values.offsetY;
+  return rect;
+}
+
 function setup(profileOverrides: Object = {}) {
   const flushRafCalls = mockRaf();
   const ctx = mockCanvasContext();
 
   jest
     .spyOn(HTMLCanvasElement.prototype, 'getContext')
     .mockImplementation(() => ctx);
 
   jest
     .spyOn(HTMLElement.prototype, 'getBoundingClientRect')
-    .mockImplementation(() => {
-      const rect = getBoundingBox(BOUNDING_BOX_WIDTH, BOUNDING_BOX_HEIGHT);
-      // Add some arbitrary offset to the bounding box to ensure that we
-      // are doing the correct thing when doing sizing calculations.
-      rect.left += BOUNDING_BOX_LEFT;
-      rect.right += BOUNDING_BOX_LEFT;
-      rect.x += BOUNDING_BOX_LEFT;
-      rect.y += BOUNDING_BOX_TOP;
-      rect.top += BOUNDING_BOX_TOP;
-      rect.bottom += BOUNDING_BOX_TOP;
-      return rect;
-    });
+    .mockImplementation(() => getBoundingBoxForViewport());
 
   // Hook up a dummy chart with a viewport.
   const DummyChart = () => <div id="dummy-chart" />;
   const ChartWithViewport = withChartViewport(DummyChart);
 
   // The viewport component started out as an unconnected component, but then it
   // started subscribing to the store an dispatching its own actions. This migration
   // wasn't completely done, so it still has a few pieces of state passed in through
@@ -527,18 +577,19 @@ function setup(profileOverrides: Object = {}) {
           {
             // None used in dummy component.
           }
         }
       />
     ),
   });
 
+  const store = storeWithProfile(getProfileFromTextSamples('A').profile);
   const view = mount(
-    <Provider store={storeWithProfile(getProfileFromTextSamples('A').profile)}>
+    <Provider store={store}>
       <ConnectedChartWithViewport />
     </Provider>
   );
 
   // WithSize uses requestAnimationFrame.
   flushRafCalls();
   view.update();
 
@@ -586,18 +637,26 @@ function setup(profileOverrides: Object = {}) {
     _dispatchToJsdomWindow('mousemove', from);
     _dispatchToJsdomWindow('mousemove', to);
     _dispatchToJsdomWindow('mouseup', to);
     // Flush any batched updates.
     flushRafCalls();
     view.update();
   }
 
+  function setBoundingBoxMock(override: $Shape<BoundingBoxOverride>): void {
+    HTMLElement.prototype.getBoundingClientRect.mockImplementation(() =>
+      getBoundingBoxForViewport(override)
+    );
+  }
+
   return {
     view,
     moveMouseAndGetLeft,
     flushRafCalls,
     getChartViewport,
     scrollAndGetViewport,
     scroll,
     clickAndDrag,
+    setBoundingBoxMock,
+    dispatch: store.dispatch,
   };
 }
